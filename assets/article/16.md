我们首先来分析Dropdown组件的源码，之后分析Dropdown源码中使用到的Rc-dropdown组件，这个组件其实才是核心，然后再来分析Dropdown-Button组件。

```tsx
import * as React from 'react';
import RcDropdown from 'rc-dropdown';
import classNames from 'classnames';
import DropdownButton from './dropdown-button';
import warning from '../_util/warning';
import Icon from '../icon';

export interface DropDownProps {
  trigger?: ('click' | 'hover' | 'contextMenu')[];
  overlay: React.ReactNode;
  onVisibleChange?: (visible?: boolean) => void;
  visible?: boolean;
  disabled?: boolean;
  align?: Object;
  getPopupContainer?: (triggerNode: Element) => HTMLElement;
  prefixCls?: string;
  className?: string;
  transitionName?: string;
  placement?: 'topLeft' | 'topCenter' | 'topRight' | 'bottomLeft' | 'bottomCenter' | 'bottomRight';
  forceRender?: boolean;
}

export default class Dropdown extends React.Component<DropDownProps, any> {
  static Button: typeof DropdownButton;
  static defaultProps = {
    prefixCls: 'ant-dropdown',
    mouseEnterDelay: 0.15,
    mouseLeaveDelay: 0.1,
    placement: 'bottomLeft',
  };

  getTransitionName() {
    const { placement = '', transitionName } = this.props;
    if (transitionName !== undefined) {
      return transitionName;
    }
    if (placement.indexOf('top') >= 0) {
      return 'slide-down';
    }
    return 'slide-up';
  }

  componentDidMount() {
    const { overlay } = this.props;
    if (overlay) {
      const overlayProps = (overlay as React.ReactElement<any>).props;
      warning(
        !overlayProps.mode || overlayProps.mode === 'vertical',
        `mode="${overlayProps.mode}" is not supported for Dropdown\'s Menu.`,
      );
    }
  }

  render() {
    const { children, prefixCls, overlay: overlayElements, trigger, disabled } = this.props;

    const child = React.Children.only(children);
    const overlay = React.Children.only(overlayElements);
    //这里面给dropdown的子节点一个ant-dropdown-trigger类，并且加上是否是失效的disabled属性，disabled属性在所有的表单元素和a标签中都有该属性，禁止交互
    const dropdownTrigger = React.cloneElement(child, {
      className: classNames(child.props.className, `${prefixCls}-trigger`),
      disabled,
    });
    // menu cannot be selectable in dropdown defaultly
    // menu should be focusable in dropdown defaultly
    const { selectable = false, focusable = true } = overlay.props;

    const expandIcon = (
      <span className={`${prefixCls}-menu-submenu-arrow`}>
        <Icon type="right" className={`${prefixCls}-menu-submenu-arrow-icon`} />
      </span>
    );
    // 这部分是Menu组件的内容，等到我分析Menu组件的时候在来分析，现在就知道能这么用就好了
    const fixedModeOverlay = typeof overlay.type === 'string'
      ? overlay : React.cloneElement(overlay, {
        mode: 'vertical',
        selectable,
        focusable,
        expandIcon,
      });

    const triggerActions = disabled ? [] : trigger;
    //设置右键菜单是否显示
    let alignPoint;
    if (triggerActions && triggerActions.indexOf('contextMenu') !== -1) {
      alignPoint = true;
    }

    return (
      <RcDropdown
        alignPoint={alignPoint}
        {...this.props}
        transitionName={this.getTransitionName()}
        trigger={triggerActions}
        overlay={fixedModeOverlay}
      >
        {dropdownTrigger}
      </RcDropdown>
    );
  }
}
```

接下来分析RcDropdown组件。

```jsx
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import Trigger from 'rc-trigger';
import placements from './placements';
import { polyfill } from 'react-lifecycles-compat';

class Dropdown extends Component {
  static propTypes = {
    minOverlayWidthMatchTrigger: PropTypes.bool,
    onVisibleChange: PropTypes.func,
    onOverlayClick: PropTypes.func,
    prefixCls: PropTypes.string,
    children: PropTypes.any,
    transitionName: PropTypes.string,
    overlayClassName: PropTypes.string,
    animation: PropTypes.any,
    align: PropTypes.object,
    overlayStyle: PropTypes.object,
    placement: PropTypes.string,
    overlay: PropTypes.node,
    trigger: PropTypes.array,
    alignPoint: PropTypes.bool,
    showAction: PropTypes.array,
    hideAction: PropTypes.array,
    getPopupContainer: PropTypes.func,
    visible: PropTypes.bool,
    defaultVisible: PropTypes.bool,
  };

  static defaultProps = {
    prefixCls: 'rc-dropdown',
    trigger: ['hover'],
    showAction: [],
    overlayClassName: '',
    overlayStyle: {},
    defaultVisible: false,
    onVisibleChange() {
    },
    placement: 'bottomLeft',
  }

  constructor(props) {
    super(props);
    if ('visible' in props) {
      this.state = {
        visible: props.visible,
      };
    } else {
      this.state = {
        visible: props.defaultVisible,
      };
    }
  }

  onClick = (e) => {
    const props = this.props;
    const overlayProps = props.overlay.props;
    // do no call onVisibleChange, if you need click to hide, use onClick and control visible
    if (!('visible' in props)) {
      this.setState({
        visible: false,
      });
    }
    if (props.onOverlayClick) {
      props.onOverlayClick(e);
    }
    if (overlayProps.onClick) {
      overlayProps.onClick(e);
    }
  }

  onVisibleChange = (visible) => {
    const props = this.props;
    if (!('visible' in props)) {
      this.setState({
        visible,
      });
    }
    props.onVisibleChange(visible);
  }

  static getDerivedStateFromProps(nextProps) {
    if ('visible' in nextProps) {
      return {
        visible: nextProps.visible,
      };
    }
    return null;
  }

  getMinOverlayWidthMatchTrigger = () => {
    const { minOverlayWidthMatchTrigger, alignPoint } = this.props;
    if ('minOverlayWidthMatchTrigger' in this.props) {
      return minOverlayWidthMatchTrigger;
    }

    return !alignPoint;
  };

  getMenuElement() {
    const { overlay, prefixCls } = this.props;
    const extraOverlayProps = {
      prefixCls: `${prefixCls}-menu`,
      onClick: this.onClick,
    };
    if (typeof overlay.type === 'string') {
      delete extraOverlayProps.prefixCls;
    }
    return React.cloneElement(overlay, extraOverlayProps);
  }

  getPopupDomNode() {
    return this.trigger.getPopupDomNode();
  }

  afterVisibleChange = (visible) => {
    if (visible && this.getMinOverlayWidthMatchTrigger()) {
      const overlayNode = this.getPopupDomNode();
      const rootNode = ReactDOM.findDOMNode(this);
      if (rootNode && overlayNode && rootNode.offsetWidth > overlayNode.offsetWidth) {
        overlayNode.style.minWidth = `${rootNode.offsetWidth}px`;
        if (this.trigger &&
            this.trigger._component &&
            this.trigger._component.alignInstance) {
          this.trigger._component.alignInstance.forceAlign();
        }
      }
    }
  }

  saveTrigger = (node) => {
    this.trigger = node;
  }

  render() {
    const {
      prefixCls, children,
      transitionName, animation,
      align, placement, getPopupContainer,
      showAction, hideAction,
      overlayClassName, overlayStyle,
      trigger, ...otherProps,
    } = this.props;

    let triggerHideAction = hideAction;
    if (!triggerHideAction && trigger.indexOf('contextMenu') !== -1) {
      triggerHideAction = ['click'];
    }

    return (
      <Trigger
        {...otherProps}
        prefixCls={prefixCls}
        ref={this.saveTrigger}
        popupClassName={overlayClassName}
        popupStyle={overlayStyle}
        builtinPlacements={placements}
        action={trigger}
        showAction={showAction}
        hideAction={triggerHideAction || []}
        popupPlacement={placement}
        popupAlign={align}
        popupTransitionName={transitionName}
        popupAnimation={animation}
        popupVisible={this.state.visible}
        afterPopupVisibleChange={this.afterVisibleChange}
        popup={this.getMenuElement()}
        onPopupVisibleChange={this.onVisibleChange}
        getPopupContainer={getPopupContainer}
      >
        {children}
      </Trigger>
    );
  }
}

polyfill(Dropdown);

export default Dropdown;
```

这其中有使用到了Trigger组件来进行渲染，我们再来看看Trigger组件的源码。

```jsx
import React from 'react';
import PropTypes from 'prop-types';
import { findDOMNode, createPortal } from 'react-dom';
import contains from 'rc-util/lib/Dom/contains'; // 接收两个参数，第一个参数是root根节点，第二个参数目标节点，判断的是目标节点是否在root节点内，判断的方式就是不断的向上去判断目标节点的父节点是否是和root节点相同，否则继续向上查找
import addEventListener from 'rc-util/lib/Dom/addEventListener'; // 封装好的事件监听添加函数，返回的对象可以进行取消监听
import ContainerRender from 'rc-util/lib/ContainerRender';
import Portal from 'rc-util/lib/Portal';
import classNames from 'classnames';

import { getAlignFromPlacement, getAlignPopupClassName } from './utils';
import Popup from './Popup';

function noop() {
}

function returnEmptyString() {
  return '';
}

function returnDocument() {
  return window.document;
}

const ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter',
  'onMouseLeave', 'onFocus', 'onBlur', 'onContextMenu'];

// 通过是否有createPortal属性，判断是否是React16版本
const IS_REACT_16 = !!createPortal;

const contextTypes = {
  rcTrigger: PropTypes.shape({
    onPopupMouseDown: PropTypes.func,
  }),
};

export default class Trigger extends React.Component {
  static propTypes = {
    children: PropTypes.any,
    // 哪些个动作可以展现popup里面的内容，可以有hover，click，focus，oncontextMenu
    action: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),

    showAction: PropTypes.any,

    hideAction: PropTypes.any,
    // 根据对齐方式添加额外的类名
    getPopupClassNameFromAlign: PropTypes.any,
    // 当popup的内容可见性变化时调用的方法
    onPopupVisibleChange: PropTypes.func,
    // 在popup的内容可见性变化之后调用的方法
    afterPopupVisibleChange: PropTypes.func,
    // 可见性变化的内容
    popup: PropTypes.oneOfType([
      PropTypes.node,
      PropTypes.func,
    ]).isRequired,
    // popup内容额外的样式
    popupStyle: PropTypes.object,
    // 前缀类名
    prefixCls: PropTypes.string,
    // 添加到popup内容的额外类名
    popupClassName: PropTypes.string,
    // 触发popup内容可视性的组件类名
    className: PropTypes.string,
    // popup默认的对齐方式
    popupPlacement: PropTypes.string,
    // 内置的位置对齐匹配表
    builtinPlacements: PropTypes.object,
    // popup内容过度动画的名字
    popupTransitionName: PropTypes.oneOfType([
      PropTypes.string,
      PropTypes.object,
    ]),
    // popup可见性变化时的动画
    popupAnimation: PropTypes.any,
    // 鼠标进入之后的延迟时间
    mouseEnterDelay: PropTypes.number,
    // 鼠标移出之后的延迟时间
    mouseLeaveDelay: PropTypes.number,
    // popup的zIndex层级css
    zIndex: PropTypes.number,
    // 获得焦点之后的延迟时间
    focusDelay: PropTypes.number,
    // 失去焦点之后的延迟时间
    blurDelay: PropTypes.number,
    // 返回popup容器的html节点
    getPopupContainer: PropTypes.func,
    // 返回document对象
    getDocument: PropTypes.func,
    // 是否要在第一次显示popup之前就要渲染popup节点
    forceRender: PropTypes.bool,
    // 在popup隐藏的时候是否要销毁popup节点
    destroyPopupOnHide: PropTypes.bool,
    // 是否要有遮罩层
    mask: PropTypes.bool,
    // 是否要支持点击遮罩层关闭popup
    maskClosable: PropTypes.bool,
    // 当popup节点对齐之后的回调函数
    onPopupAlign: PropTypes.func,
    // popup的对齐配置对象
    popupAlign: PropTypes.object,
    // popup内容是否是可见的（到现在的理解是只要设置了这个属性，那么popup的可见性就不会改变一样）
    popupVisible: PropTypes.bool,
    // 在最开始的时候popup是否是可见的
    defaultPopupVisible: PropTypes.bool,
    // 遮罩层的过度方式
    maskTransitionName: PropTypes.oneOfType([
      PropTypes.string,
      PropTypes.object,
    ]),
    // 遮罩层的动画
    maskAnimation: PropTypes.string,
    // 让popup的div随着触发元素进行伸展，可选的枚举类型有：width，minWidth，height，minHeight，也可以将height和minWidth混合使用
    stretch: PropTypes.string,
    // popup内容的位置是否是与鼠标的位置对齐
    alignPoint: PropTypes.bool, // Maybe we can support user pass position in the future
  };
  // 避免使用props传递的方式进行数据下发，使用context进行传递数据，不过官方并不推荐该种数据传递方式，并且不要指望用context来进行属性的更新
  static contextTypes = contextTypes;
  // 使用context的方式继续向下传递数据
  static childContextTypes = contextTypes;
  // 默认的属性值
  static defaultProps = {
    prefixCls: 'rc-trigger-popup',
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop,
    afterPopupVisibleChange: noop,
    onPopupAlign: noop,
    popupClassName: '',
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
  };

  constructor(props) {
    super(props);
    // 设置初始时popup的可见性，默认的可见性属性优先级没有popupVisible的优先级高
    let popupVisible;
    if ('popupVisible' in props) {
      popupVisible = !!props.popupVisible;
    } else {
      popupVisible = !!props.defaultPopupVisible;
    }
    // 设置上一次的popup可见性是什么
    this.prevPopupVisible = popupVisible;

    this.state = {
      popupVisible,
    };
  }
  // 继续传递rcTrigger方法
  getChildContext() {
    return {
      rcTrigger: {
        onPopupMouseDown: this.onPopupMouseDown,
      },
    };
  }
  // 为每一种情况都定义了处理函数，如果在子节点上定义了处理函数就调用，在自身节点上定义了处理函数也调用，这两个处理函数是互相并不影响的
  componentWillMount() {
    ALL_HANDLERS.forEach((h) => {
      this[`fire${h}`] = (e) => {
        this.fireEvents(h, e);
      };
    });
  }

  componentDidMount() {
    // 为什么要在组件装配阶段调用生命周期中的组件已经更新方法，我的理解就是如果popup默认是显示的话，那么就需要添加点击监控来将popup隐藏
    this.componentDidUpdate({}, {
      popupVisible: this.state.popupVisible,
    });
  }
  // 接收一个参数，nextProps，装配期间不会调用，只会在属性更新期间调用，推荐使用新的生命周期函数
  componentWillReceiveProps({ popupVisible }) {
    if (popupVisible !== undefined) {
      this.setState({
        popupVisible,
      });
    }
  }
  // 第一个参数是以前的props，第二个参数是以前的state，这个生命周期函数主要的工作就是当popup出现的时候添加事件监听来隐藏popup，当popup是隐藏状态时移除所有的监听函数
  componentDidUpdate(_, prevState) {
    const props = this.props;
    const state = this.state;
    // 如果之前的popup可见状态和现在的popup可见状态不一样的，则触发popup状态更新之后的回调函数，并且传入现在的popup可见状态
    const triggerAfterPopupVisibleChange = () => {
      if (prevState.popupVisible !== state.popupVisible) {
        props.afterPopupVisibleChange(state.popupVisible);
      }
    };
    // 如果不是React16执行的逻辑，这块我不是特别清为什么要这么写，因为我没有学习过16之前的版本比16少什么东西是需要在这这么做的，因位现在基本上使用的都是16之后的版本，所以向前兼容的代码逻辑我们先不分析了
    if (!IS_REACT_16) {
      this.renderComponent(null, triggerAfterPopupVisibleChange);
    }

    this.prevPopupVisible = prevState.popupVisible;

    // We must listen to `mousedown` or `touchstart`, edge case:
    // https://github.com/ant-design/ant-design/issues/5804
    // https://github.com/react-component/calendar/issues/250
    // https://github.com/react-component/trigger/issues/50
    if (state.popupVisible) {
      let currentDocument;
      // 首先判断有没有点击到外面的处理函数，其次是对于点击是不是有必要处理点击隐藏的动作
      if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
        currentDocument = props.getDocument();
        this.clickOutsideHandler = addEventListener(currentDocument,
          'mousedown', this.onDocumentClick);
      }
      // always hide on mobile
      if (!this.touchOutsideHandler) {
        currentDocument = currentDocument || props.getDocument();
        this.touchOutsideHandler = addEventListener(currentDocument,
          'touchstart', this.onDocumentClick);
      }
      // close popup when trigger type contains 'onContextMenu' and document is scrolling.
      if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
        currentDocument = currentDocument || props.getDocument();
        this.contextMenuOutsideHandler1 = addEventListener(currentDocument,
          'scroll', this.onContextMenuClose);
      }
      // close popup when trigger type contains 'onContextMenu' and window is blur.
      if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
        this.contextMenuOutsideHandler2 = addEventListener(window,
          'blur', this.onContextMenuClose);
      }
      return;
    }
    // 如果popup是不可见的，则取消所有的事件监听函数
    this.clearOutsideHandler();
  }
  // 取消所有的定时器以及事件监听函数
  componentWillUnmount() {
    this.clearDelayTimer();
    this.clearOutsideHandler();
    clearTimeout(this.mouseDownTimeout);
  }

  onMouseEnter = (e) => {
    const { mouseEnterDelay } = this.props;
    this.fireEvents('onMouseEnter', e);
    this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e);
  }

  onMouseMove = (e) => {
    this.fireEvents('onMouseMove', e);
    this.setPoint(e);
  };

  onMouseLeave = (e) => {
    this.fireEvents('onMouseLeave', e);
    this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
  }

  onPopupMouseEnter = () => {
    this.clearDelayTimer();
  }
  // 这个方法没太看懂要干啥。。。。。
  onPopupMouseLeave = (e) => {
    // https://github.com/react-component/trigger/pull/13
    // react bug?
    if (e.relatedTarget && !e.relatedTarget.setTimeout &&
      this._component &&
      this._component.getPopupDomNode &&
      contains(this._component.getPopupDomNode(), e.relatedTarget)) {
      return;
    }
    this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
  }

  onFocus = (e) => {
    this.fireEvents('onFocus', e);
    // incase focusin and focusout
    this.clearDelayTimer();
    if (this.isFocusToShow()) {
      this.focusTime = Date.now();
      this.delaySetPopupVisible(true, this.props.focusDelay);
    }
  }

  onMouseDown = (e) => {
    this.fireEvents('onMouseDown', e);
    this.preClickTime = Date.now();
  }

  onTouchStart = (e) => {
    this.fireEvents('onTouchStart', e);
    this.preTouchTime = Date.now();
  }

  onBlur = (e) => {
    this.fireEvents('onBlur', e);
    this.clearDelayTimer();
    if (this.isBlurToHide()) {
      this.delaySetPopupVisible(false, this.props.blurDelay);
    }
  }
  // 右键事件处理函数
  onContextMenu = (e) => {
    e.preventDefault();
    this.fireEvents('onContextMenu', e);
    this.setPopupVisible(true, e);
  }

  onContextMenuClose = () => {
    if (this.isContextMenuToShow()) {
      this.close();
    }
  }

  onClick = (event) => {
    this.fireEvents('onClick', event);
    // focus will trigger click
    // 获得焦点事件也有可能触发了点击事件，那么这两个事件处理函数只需要触发一个就行了，所以要判断一下这次的点击事件是不是由获得焦点事件产生的，怎么判断：获得焦点事件有触发时间，点击事件也有触发时间，如果两者的触发时间之差的绝对值小于20毫秒的话我们就认为这是由于获得焦点事件触发的点击事件
    // input框的事件触发顺序是这样的，mousedown -> focus -> mouseup -> click
    if (this.focusTime) {
      let preTime;
      if (this.preClickTime && this.preTouchTime) {
        preTime = Math.min(this.preClickTime, this.preTouchTime);
      } else if (this.preClickTime) {
        preTime = this.preClickTime;
      } else if (this.preTouchTime) {
        preTime = this.preTouchTime;
      }
      if (Math.abs(preTime - this.focusTime) < 20) {
        return;
      }
      this.focusTime = 0;
    }
    this.preClickTime = 0;
    this.preTouchTime = 0;
    if (event && event.preventDefault) {
      event.preventDefault();
    }
    // 这里需要判断一下是不是需要点击事件触发popup的显示与隐藏
    const nextVisible = !this.state.popupVisible;
    if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
      this.setPopupVisible(!this.state.popupVisible, event);
    }
  }

  onPopupMouseDown = (...args) => {
    const { rcTrigger = {} } = this.context;
    this.hasPopupMouseDown = true;

    clearTimeout(this.mouseDownTimeout);
    this.mouseDownTimeout = setTimeout(() => {
      this.hasPopupMouseDown = false;
    }, 0);

    if (rcTrigger.onPopupMouseDown) {
      rcTrigger.onPopupMouseDown(...args);
    }
  };

  onDocumentClick = (event) => {
    // 如果有遮罩层，并且点击遮罩层不会关闭popup，那么点击之后什么也不会做
    if (this.props.mask && !this.props.maskClosable) {
      return;
    }

    const target = event.target;
    const root = findDOMNode(this);
    // 首先要确保target不在root内，其次，没有鼠标点击在popup内
    if (!contains(root, target) && !this.hasPopupMouseDown) {
      this.close();
    }
  }

  getPopupDomNode() {
    // for test
    if (this._component && this._component.getPopupDomNode) {
      return this._component.getPopupDomNode();
    }
    return null;
  }

  getRootDomNode = () => {
    return findDOMNode(this);
  }

  getPopupClassNameFromAlign = (align) => {
    const className = [];
    const {
      popupPlacement, builtinPlacements, prefixCls, alignPoint,
      getPopupClassNameFromAlign,
    } = this.props;
    if (popupPlacement && builtinPlacements) {
      className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint));
    }
    if (getPopupClassNameFromAlign) {
      className.push(getPopupClassNameFromAlign(align));
    }
    return className.join(' ');
  }

  getPopupAlign() {
    const props = this.props;
    const { popupPlacement, popupAlign, builtinPlacements } = props;
    if (popupPlacement && builtinPlacements) {
      return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
    }
    return popupAlign;
  }
  // 返回popup组件
  getComponent = () => {
    const {
      prefixCls, destroyPopupOnHide, popupClassName, action,
      onPopupAlign, popupAnimation, popupTransitionName, popupStyle,
      mask, maskAnimation, maskTransitionName, zIndex, popup, stretch,
      alignPoint,
    } = this.props;
    const { popupVisible, point } = this.state;
    // 返回popup的对齐方式
    const align = this.getPopupAlign();
    
    const mouseProps = {};
    if (this.isMouseEnterToShow()) {
      // 当鼠标进入到popup中时清除定时器，什么也不做
      mouseProps.onMouseEnter = this.onPopupMouseEnter;
    }
    if (this.isMouseLeaveToHide()) {
      mouseProps.onMouseLeave = this.onPopupMouseLeave;
    }
    // 这块也没太看懂是要干啥。。。。
    mouseProps.onMouseDown = this.onPopupMouseDown;
    mouseProps.onTouchStart = this.onPopupMouseDown;

    return (
      <Popup
        prefixCls={prefixCls}
        destroyPopupOnHide={destroyPopupOnHide}
        visible={popupVisible}
        point={alignPoint && point}
        className={popupClassName}
        action={action}
        align={align}
        onAlign={onPopupAlign}
        animation={popupAnimation}
        getClassNameFromAlign={this.getPopupClassNameFromAlign}
        {...mouseProps}
        stretch={stretch}
        getRootDomNode={this.getRootDomNode}
        style={popupStyle}
        mask={mask}
        zIndex={zIndex}
        transitionName={popupTransitionName}
        maskAnimation={maskAnimation}
        maskTransitionName={maskTransitionName}
        ref={this.savePopup}
      >
        {typeof popup === 'function' ? popup() : popup}
      </Popup>
    );
  }
  // 返回popup的父节点，如果没有指定getPopupContainer那么就默认加到body下的新建的div，并且该div的定位css是绝对定位的
  getContainer = () => {
    const { props } = this;
    const popupContainer = document.createElement('div');
    // Make sure default popup container will never cause scrollbar appearing
    // https://github.com/react-component/trigger/issues/41
    popupContainer.style.position = 'absolute';
    popupContainer.style.top = '0';
    popupContainer.style.left = '0';
    popupContainer.style.width = '100%';
    const mountNode = props.getPopupContainer ?
      props.getPopupContainer(findDOMNode(this)) : props.getDocument().body;
    mountNode.appendChild(popupContainer);
    return popupContainer;
  }
  // 设置popup的可见性，但是只要传入了popupVisible这个属性就不改变popup的可见性
  /**
   * @param popupVisible    Show or not the popup element
   * @param event           SyntheticEvent, used for `pointAlign`
   */
  setPopupVisible(popupVisible, event) {
    const { alignPoint } = this.props;

    this.clearDelayTimer();

    if (this.state.popupVisible !== popupVisible) {
      if (!('popupVisible' in this.props)) {
        this.setState({ popupVisible });
      }
      this.props.onPopupVisibleChange(popupVisible);
    }
    // 如果需要popup的显示位置随着鼠标的位置进行改变，那么就需要记录下当时鼠标的位置
    // Always record the point position since mouseEnterDelay will delay the show
    if (alignPoint && event) {
      this.setPoint(event);
    }
  }

  setPoint = (point) => {
    const { alignPoint } = this.props;
    if (!alignPoint || !point) return;

    this.setState({
      point: {
        pageX: point.pageX,
        pageY: point.pageY,
      },
    });
  }

  handlePortalUpdate = () => {
    if (this.prevPopupVisible !== this.state.popupVisible) {
      this.props.afterPopupVisibleChange(this.state.popupVisible);
    }
  }

  delaySetPopupVisible(visible, delayS, event) {
    const delay = delayS * 1000;
    this.clearDelayTimer();
    if (delay) {
      const point = event ? { pageX: event.pageX, pageY: event.pageY } : null;
      this.delayTimer = setTimeout(() => {
        this.setPopupVisible(visible, point);
        this.clearDelayTimer();
      }, delay);
    } else {
      this.setPopupVisible(visible, event);
    }
  }

  clearDelayTimer() {
    if (this.delayTimer) {
      clearTimeout(this.delayTimer);
      this.delayTimer = null;
    }
  }

  clearOutsideHandler() {
    if (this.clickOutsideHandler) {
      this.clickOutsideHandler.remove();
      this.clickOutsideHandler = null;
    }

    if (this.contextMenuOutsideHandler1) {
      this.contextMenuOutsideHandler1.remove();
      this.contextMenuOutsideHandler1 = null;
    }

    if (this.contextMenuOutsideHandler2) {
      this.contextMenuOutsideHandler2.remove();
      this.contextMenuOutsideHandler2 = null;
    }

    if (this.touchOutsideHandler) {
      this.touchOutsideHandler.remove();
      this.touchOutsideHandler = null;
    }
  }
  // 为指定的事件（event）指定事件处理函数，这些处理函数都是用户传进来的响应函数
  createTwoChains(event) {
    const childPros = this.props.children.props;
    const props = this.props;
    if (childPros[event] && props[event]) {
      return this[`fire${event}`];
    }
    return childPros[event] || props[event];
  }

  isClickToShow() {
    const { action, showAction } = this.props;
    return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
  }
  // 判断是不是需要右键出现菜单,同样有右键出现菜单那么就需要点击其他区域的时候撤销右键菜单
  isContextMenuToShow() {
    const { action, showAction } = this.props;
    return action.indexOf('contextMenu') !== -1 || showAction.indexOf('contextMenu') !== -1;
  }
  // 判断是不是有必要处理点击隐藏的动作，就看action触发中是不是有点击的动作和隐藏的动作中是不是有点击的动作
  isClickToHide() {
    const { action, hideAction } = this.props;
    return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
  }
  // hover状态的模拟使用鼠标进入的事件来代替的，并且可以设置时间的延迟
  isMouseEnterToShow() {
    const { action, showAction } = this.props;
    return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
  }

  isMouseLeaveToHide() {
    const { action, hideAction } = this.props;
    return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
  }

  isFocusToShow() {
    const { action, showAction } = this.props;
    return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
  }

  isBlurToHide() {
    const { action, hideAction } = this.props;
    return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
  }

  forcePopupAlign() {
    if (this.state.popupVisible && this._component && this._component.alignInstance) {
      this._component.alignInstance.forceAlign();
    }
  }
  // 触发用户传进来的对应事件的回调
  fireEvents(type, e) {
    const childCallback = this.props.children.props[type];
    if (childCallback) {
      childCallback(e);
    }
    const callback = this.props[type];
    if (callback) {
      callback(e);
    }
  }

  close() {
    this.setPopupVisible(false);
  }

  savePopup = (node) => {
    this._component = node;
  }

  render() {
    const { popupVisible } = this.state;
    const { children, forceRender, alignPoint, className } = this.props;
    const child = React.Children.only(children);
    const newChildProps = { key: 'trigger' };
    // 为对应的事件添加事件处理函数，分两种情况，如果popup需要监听对应的事件来进行显示与隐藏的调整，那么在完成自身事件监听额同时调用用户传进来的事件回调，如果popup不需要监听对应的事件，那么就只需要调用用户的事件回调
    if (this.isContextMenuToShow()) {
      newChildProps.onContextMenu = this.onContextMenu;
    } else {
      newChildProps.onContextMenu = this.createTwoChains('onContextMenu');
    }

    if (this.isClickToHide() || this.isClickToShow()) {
      newChildProps.onClick = this.onClick;
      newChildProps.onMouseDown = this.onMouseDown;
      newChildProps.onTouchStart = this.onTouchStart;
    } else {
      newChildProps.onClick = this.createTwoChains('onClick');
      newChildProps.onMouseDown = this.createTwoChains('onMouseDown');
      newChildProps.onTouchStart = this.createTwoChains('onTouchStart');
    }
    // 如果有时间的延迟显示的话那么就不设置对齐点，利用鼠标的移动事件来设置对齐点
    if (this.isMouseEnterToShow()) {
      newChildProps.onMouseEnter = this.onMouseEnter;
      if (alignPoint) {
        newChildProps.onMouseMove = this.onMouseMove;
      }
    } else {
      newChildProps.onMouseEnter = this.createTwoChains('onMouseEnter');
    }
    if (this.isMouseLeaveToHide()) {
      newChildProps.onMouseLeave = this.onMouseLeave;
    } else {
      newChildProps.onMouseLeave = this.createTwoChains('onMouseLeave');
    }
    if (this.isFocusToShow() || this.isBlurToHide()) {
      newChildProps.onFocus = this.onFocus;
      newChildProps.onBlur = this.onBlur;
    } else {
      newChildProps.onFocus = this.createTwoChains('onFocus');
      newChildProps.onBlur = this.createTwoChains('onBlur');
    }
    // 设置子节点的类名，child的类名和设置在该组件上的类名都是添加到触发popup显示与隐藏的节点上的
    const childrenClassName = classNames(child && child.props && child.props.className, className);
    if (childrenClassName) {
      newChildProps.className = childrenClassName;
    }
    const trigger = React.cloneElement(child, newChildProps);
    // 16以前的版本我这里不做分析，因为我也不知道16之前的版本的情况
    if (!IS_REACT_16) {
      return (
        <ContainerRender
          parent={this}
          visible={popupVisible}
          autoMount={false}
          forceRender={forceRender}
          getComponent={this.getComponent}
          getContainer={this.getContainer}
        >
          {({ renderComponent }) => {
            this.renderComponent = renderComponent;
            return trigger;
          }}
        </ContainerRender>
      );
    }

    let portal;
    // prevent unmounting after it's rendered
    if (popupVisible || this._component || forceRender) {
      // 一个用于将组件渲染到指定的容器中的组件，从文档中看到接收两个参数，一个是getContainer：一个函数，返回指定的容器组件，还有就是children属性，要被渲染的节点
      portal = (
        <Portal
          key="portal"
          getContainer={this.getContainer}
          didUpdate={this.handlePortalUpdate}
        >
          {this.getComponent()}
        </Portal>
      );
    }

    return [
      trigger,
      portal,
    ];
  }
}
```

我们在分析一下Popup组件

```jsx
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import Align from 'rc-align';
import Animate from 'rc-animate';
import PopupInner from './PopupInner';
import LazyRenderBox from './LazyRenderBox';
import { saveRef } from './utils';

class Popup extends Component {
  static propTypes = {
    // 是否可见
    visible: PropTypes.bool,
    style: PropTypes.object,
    getClassNameFromAlign: PropTypes.func,
    onAlign: PropTypes.func,
    getRootDomNode: PropTypes.func,
    align: PropTypes.any,
    destroyPopupOnHide: PropTypes.bool,
    className: PropTypes.string,
    prefixCls: PropTypes.string,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onMouseDown: PropTypes.func,
    onTouchStart: PropTypes.func,
    stretch: PropTypes.string,
    children: PropTypes.node,
    point: PropTypes.shape({
      pageX: PropTypes.number,
      pageY: PropTypes.number,
    }),
  };

  constructor(props) {
    super(props);

    this.state = {
      // Used for stretch
      stretchChecked: false,
      targetWidth: undefined,
      targetHeight: undefined,
    };

    this.savePopupRef = saveRef.bind(this, 'popupInstance');
    this.saveAlignRef = saveRef.bind(this, 'alignInstance');
  }

  componentDidMount() {
    this.rootNode = this.getPopupDomNode();
    this.setStretchSize();
  }

  componentDidUpdate() {
    this.setStretchSize();
  }

  onAlign = (popupDomNode, align) => {
    const props = this.props;
    const currentAlignClassName = props.getClassNameFromAlign(align);
    // FIX: https://github.com/react-component/trigger/issues/56
    // FIX: https://github.com/react-component/tooltip/issues/79
    if (this.currentAlignClassName !== currentAlignClassName) {
      this.currentAlignClassName = currentAlignClassName;
      popupDomNode.className = this.getClassName(currentAlignClassName);
    }
    props.onAlign(popupDomNode, align);
  }

  // Record size if stretch needed
  setStretchSize = () => {
    const { stretch, getRootDomNode, visible } = this.props;
    const { stretchChecked, targetHeight, targetWidth } = this.state;
    // 相当于说如果是不可见的或者是不可伸缩的就需不要再做任何的记录了
    if (!stretch || !visible) {
      if (stretchChecked) {
        this.setState({ stretchChecked: false });
      }
      return;
    }

    const $ele = getRootDomNode();
    if (!$ele) return;

    const height = $ele.offsetHeight;
    const width = $ele.offsetWidth;
    // 记录外层的宽高，并且标记是true（此处的宽高是border-box）
    if (targetHeight !== height || targetWidth !== width || !stretchChecked) {
      this.setState({
        stretchChecked: true,
        targetHeight: height,
        targetWidth: width,
      });
    }
  };
  // 这块大家可能会疑惑，代码中也没有出现this中有popupInstance这个属性呀，这块为什么会出现这种写法，对么？其实是上面的saveRef起的作用，saveRef返回一个绑定好this引用以及popupInstance属性的一个方法，后面渲染的时候将这个方法传递给ref属性，自动绑定的dom节点，仔细在理解一下就可以看的懂了
  getPopupDomNode() {
    return ReactDOM.findDOMNode(this.popupInstance);
  }

  getTargetElement = () => {
    return this.props.getRootDomNode();
  }

  // `target` on `rc-align` can accept as a function to get the bind element or a point.
  // ref: https://www.npmjs.com/package/rc-align
  getAlignTarget = () => {
    const { point } = this.props;
    if (point) {
      return point;
    }
    return this.getTargetElement;
  }
  // 返回动画或者是过度的名称，如果都有的话过度的优先级高于动画的优先级
  getMaskTransitionName() {
    const props = this.props;
    let transitionName = props.maskTransitionName;
    const animation = props.maskAnimation;
    if (!transitionName && animation) {
      transitionName = `${props.prefixCls}-${animation}`;
    }
    return transitionName;
  }

  getTransitionName() {
    const props = this.props;
    let transitionName = props.transitionName;
    if (!transitionName && props.animation) {
      transitionName = `${props.prefixCls}-${props.animation}`;
    }
    return transitionName;
  }
  // 返回当前的类名，有组件预设类名，用户传进来的类名，以及当前的对齐方式的类名
  getClassName(currentAlignClassName) {
    return `${this.props.prefixCls} ${this.props.className} ${currentAlignClassName}`;
  }

  getPopupElement() {
    const { savePopupRef } = this;
    const { stretchChecked, targetHeight, targetWidth } = this.state;
    const {
      align, visible,
      prefixCls, style, getClassNameFromAlign,
      destroyPopupOnHide, stretch, children,
      onMouseEnter, onMouseLeave, onMouseDown, onTouchStart,
    } = this.props;
    // 设置className
    const className = this.getClassName(this.currentAlignClassName ||
      getClassNameFromAlign(align));
    const hiddenClassName = `${prefixCls}-hidden`;

    if (!visible) {
      this.currentAlignClassName = null;
    }
    // 设置popup的伸缩样式
    const sizeStyle = {};
    if (stretch) {
      // Stretch with target
      if (stretch.indexOf('height') !== -1) {
        sizeStyle.height = targetHeight;
      } else if (stretch.indexOf('minHeight') !== -1) {
        sizeStyle.minHeight = targetHeight;
      }
      if (stretch.indexOf('width') !== -1) {
        sizeStyle.width = targetWidth;
      } else if (stretch.indexOf('minWidth') !== -1) {
        sizeStyle.minWidth = targetWidth;
      }

      // Delay force align to makes ui smooth
      if (!stretchChecked) {
        sizeStyle.visibility = 'hidden';
        setTimeout(() => {
          if (this.alignInstance) {
            this.alignInstance.forceAlign();
          }
        }, 0);
      }
    }
    // 将上面所得的样式整合到一起
    const newStyle = {
      ...sizeStyle,
      ...style,
      ...this.getZIndexStyle(),
    };
    // 整合popup显示组件的输入属性
    const popupInnerProps = {
      className,
      prefixCls,
      ref: savePopupRef,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onTouchStart,
      style: newStyle,
    };
    // 如果需要不显示就销毁组件，那么类似于Vue中的条件渲染一样，如果不需要这样，那么只需要将组件隐藏或者是display:none就可以了，下面的组件不在具体的分析了，Dropdown组件确实是涉及到太多的组件了，分析的已经够多了，以后有时间可以继续对其他的组件进行更加深入的分析
    if (destroyPopupOnHide) {
      return (
        <Animate
          component=""
          exclusive
          transitionAppear
          transitionName={this.getTransitionName()}
        >
          {visible ? (
            <Align
              target={this.getAlignTarget()}
              key="popup"
              ref={this.saveAlignRef}
              monitorWindowResize
              align={align}
              onAlign={this.onAlign}
            >
              <PopupInner
                visible
                {...popupInnerProps}
              >
                {children}
              </PopupInner>
            </Align>
          ) : null}
        </Animate>
      );
    }

    return (
      <Animate
        component=""
        exclusive
        transitionAppear
        transitionName={this.getTransitionName()}
        showProp="xVisible"
      >
        <Align
          target={this.getAlignTarget()}
          key="popup"
          ref={this.saveAlignRef}
          monitorWindowResize
          xVisible={visible}
          childrenProps={{ visible: 'xVisible' }}
          disabled={!visible}
          align={align}
          onAlign={this.onAlign}
        >
          <PopupInner
            hiddenClassName={hiddenClassName}
            {...popupInnerProps}
          >
            {children}
          </PopupInner>
        </Align>
      </Animate>
    );
  }
  // 就是返回css中的zIndex属性
  getZIndexStyle() {
    const style = {};
    const props = this.props;
    if (props.zIndex !== undefined) {
      style.zIndex = props.zIndex;
    }
    return style;
  }

  getMaskElement() {
    const props = this.props;
    let maskElement;
    if (props.mask) {
      const maskTransition = this.getMaskTransitionName();
      maskElement = (
        <LazyRenderBox
          style={this.getZIndexStyle()}
          key="mask"
          className={`${props.prefixCls}-mask`}
          hiddenClassName={`${props.prefixCls}-mask-hidden`}
          visible={props.visible}
        />
      );
      if (maskTransition) {
        maskElement = (
          <Animate
            key="mask"
            showProp="visible"
            transitionAppear
            component=""
            transitionName={maskTransition}
          >
            {maskElement}
          </Animate>
        );
      }
    }
    return maskElement;
  }

  render() {
    return (
      <div>
        {this.getMaskElement()}
        {this.getPopupElement()}
      </div>
    );
  }
}

export default Popup;
```

到目前为止，做一个总结，这个组件确实是用到了太多的组件，逻辑复杂程度也是很高，我来简单的总结一下思路，以供以后写类似的组件提供思路：

- 首先将这个组件分为两个部分，一个部分是触发显示与否的部分，一个是popup弹窗部分，并且popup弹窗部分又可以分为两个部分，一个部分是popup弹窗，一个部分是mask蒙层
- 我们再来看一下触发的时机，有hover，click，contextMenu，为了简单点，我们暂时先不考虑contextMenu的触发方式，并且这种方式可能在网页中使用到的情况也不是很多，hover我们可以使用mouseEnter和mouseLeave来模拟，click可以监听的事件触发有mouseDown，mouseUp，click，代码中还涉及到了focus的触发方式，对于触屏还有touchStart，touchEnd。这里注意一下触发的先后顺序，mouseDown -> focus -> mouseUp ->click， 以及在多个事件上添加监听之后，处理逻辑问题，是不是会存在多次逻辑的重复处理，以及先后顺序的问题，还有就是触发popup的事件处理时机以及popup消失的事件处理，动画的问题暂时也先不考虑了，为了简化问题。对齐方式的处理逻辑等等，这个组件确实是考虑到了很多种情况，我们在写的时候可能不需要覆盖这么全的情况，以后有机会可以尝试自己实现一个，仅仅考虑hover和click的方式。
- 还有一个问题，就是popup的定位问题，这里是通过absolute定位，并且相对的是body，我之前的想法是通过一个div包裹住触发的button以及popup元素，将div相对定位，然后popup相对div进行定位，这里我没想到这种方式的缺点在哪里，以后有机会的时候可以实践一下，看看这两种方式的优缺点都是什么。

还是需要一定的尝试的，不尝试永远不知道怎么来实现。

我们再来看一下Dropdown-button的组件代码，这里代码逻辑其实已经很简单了，大部分逻辑都是在复用以前理解的Dropdown组件。

```tsx
import * as React from 'react';
import Button from '../button';
import { ButtonHTMLType } from '../button/button';
import { ButtonGroupProps } from '../button/button-group';
import Dropdown, { DropDownProps } from './dropdown';
import classNames from 'classnames';
const ButtonGroup = Button.Group;

export interface DropdownButtonProps extends ButtonGroupProps, DropDownProps {
  type?: 'primary' | 'ghost' | 'dashed';
  htmlType?: ButtonHTMLType;
  disabled?: boolean;
  onClick?: React.MouseEventHandler<HTMLButtonElement>;
  children?: any;
}

export default class DropdownButton extends React.Component<DropdownButtonProps, any> {
  static defaultProps = {
    placement: 'bottomRight',
    type: 'default',
    prefixCls: 'ant-dropdown-button',
  };

  render() {
    const {
      type, disabled, onClick, htmlType, children,
      prefixCls, className, overlay, trigger, align,
      visible, onVisibleChange, placement, getPopupContainer,
      ...restProps
    } = this.props;

    const dropdownProps = {
      align,
      overlay,
      disabled,
      trigger: disabled ? [] : trigger,
      onVisibleChange,
      placement,
      getPopupContainer,
    } as DropDownProps;
    if ('visible' in this.props) {
      dropdownProps.visible = visible;
    }

    return (
      <ButtonGroup
        {...restProps}
        className={classNames(prefixCls, className)}
      >
        <Button
          type={type}
          disabled={disabled}
          onClick={onClick}
          htmlType={htmlType}
        >
          {children}
        </Button>
        <Dropdown {...dropdownProps}>
          <Button type={type} icon="ellipsis" />
        </Dropdown>
      </ButtonGroup>
    );
  }
}
```

